# Mark-by-Stack

# [문제 분석]
-요구사항 및 제한사항
구현해야 하는 기능은 중위 표기식을 후위 표기식으로 바꾸고, 컴퓨터가 계산하는 방법인 스택을 이용하여 계산해보는 기능을 구현해야 한다. 이 때 제한사항은 입력할 때 여러 가지 오류가 있을 수 있으니 모두 예외처리로 할 것을 고려해주어야 한다.

# [배경 지식]
-기능적 배경지식 : 이 문제를 해결하기 위해서 우선 중위 표기식이 후위 표기식으로 어떻게 바뀌는지 그 과정을 알아야 하고, 그리고 후위표기식의 계산순서가 어떻게 되는지 알고 있어야한다.

-자료구조 배경지식 : 이번 문제를 해결하기 위해 사용한 자료구조는 스택이다. 스택은 후입선출로써 나중에 들어온 값이 제일 먼저 나가는 구조이다. 컴퓨터 계산에서도 이와 같은 스택구조를 활용하여 더 빠른 계산을 할 수 있다고 한다. 사람이 주로 쓰는 중위 표기식은 연산이 여러 개일 때 순서대로 계산하지 못하고 뒤에부터 계산해야 하는 경우가 있다. 하지만 컴퓨터는 처음부터 끝까지 한번에 계산할 수 있는 스택 자료구조를 사용하고 있기 때문에 효율적이고 빠른 처리가 가능하다.

# [자료구조/알고리즘의 설명]
-자료구조 활용 : int eval(char exp[]) 이 함수는 후위 표기식을 계산해주는 함수이다. 여기서 스택구조가 활용이 된다. 숫자같은 경우는 제한 사항 없이 스택에 들어가지만 연산자가 들어가게 되면 해당하는 연산자 앞의 두 숫자를 계산시키고 다시 스택에 넣는 형식이다. push,pop,peek 함수도 마찬가지로 스택구조에서 넣고 빼고 찾을 때 필요한 함수 이므로 활용 된다고 볼 수 있다.

[소스코드 분석]
# 함수 정리
void init_stack(StackType *s);
- 스택타입 구조체s를 초기화한다.
- 
int is_empty(StackType *s);
- s가 비어있으면 1을 반환하고 아니면 0을 반환한다.

int is_full(StackType *s);
- s가 꽉 차있으면 1을 반환 아니면 0을 반환한다.

void push(StackType *s, element item);
- s가 꽉 차있으면 에러 메시지 뜨게하고 아니면 s에 item을 넣는다.

element pop(StackType *s);
- s가 비어있으면 에러 메시지 뜨게하고 아니면 s에서 top의 데이터를 뺀다.

element peek(StackType *s);
- s가 비어있으면 에러 메시지 뜨게하고 아니면 s에서 top의 데이터만 반환한다.

int eval(char exp[]);
- 중위 표기식에서 후위 표기식으로 바뀐 식을 계산하고 그 값을 반환한다.

int prec(char op);
- op의 우선순위 별로 값을 반환한다.

element* infix_to_postfix (char exp[]);
- 0으로 나눠주는 경우 예외처리, 괄호매칭이 안 되는 경우 예외처리, 예외문자 포함된 식 예외처리, 한 자리 수 이상의 입력 포함 예외처리, 숫자 개수와 연산자 개수 오류인 경우 예외처리하고 난 후 예외가 없는 정상적인 중위 표기식을 후위 표기식으로 변환하고 이 배열을 반환한다.

int main(void)
- 중위 표기식을 사용자로부터 입력받고 그 식이 후위 표기식으로 어떻게 바뀌는지 출력해주고 계산까지 해주는 함수이다.

# 결과화면
![image](https://user-images.githubusercontent.com/76897007/141433037-bed2a021-0e93-422f-9be9-5c70d0561999.png)
![image](https://user-images.githubusercontent.com/76897007/141433054-c123ae81-6902-4922-ba52-e3a94852aff7.png)
